import asyncio
from urllib.parse import unquote
import configparser
import concurrent.futures

from telegram import InlineQueryResultArticle, InputTextMessageContent, Update, InlineKeyboardMarkup, InlineKeyboardButton, KeyboardButton, ReplyKeyboardMarkup
from telegram.constants import ParseMode
from telegram.ext import Application, CommandHandler, ContextTypes, InlineQueryHandler, MessageHandler, filters

from modules.sql import add_message, read_thread
from modules.utils import *

# Read telegram bot token from config.ini
config = configparser.ConfigParser()                                     
config.read('config.ini')

token = config.get('TELEGRAM', 'BOT_TOKEN')


# This function sends a welcoming message when the bot starts
async def cmd_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("Hello! Main features:\n- Threaded ChatGPT bot using Bing: The bot maintains isolated threads of messages, allowing for separate conversations to be held concurrently.\n- Image Generation: The bot generates images using the Dalle library. Images can be generated by using the /image command or by providing a prompt in a message.\n- Conversation Management: The bot maintains a conversation thread in a SQLite database, allowing for persistent and organized conversations.")


async def cmd_help(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "Welcome to our bot! Here's how you can use it:\n"
        "- /start: Starts the bot and sends a welcoming message.\n"
        "- /image [prompt]: Generates an image based on the provided prompt.\n"
        "- Any text message: The bot will process all non-command messages. It downloads any attached image and gets the prompt from the message text. It then generates a response based on the message thread and the image.\n"
        "\n"
        "Main features:\n"
        "- Threaded ChatGPT bot using Bing: The bot maintains isolated threads of messages, allowing for separate conversations to be held concurrently.\n"
        "- Image Generation: The bot generates images using the Dalle library. Images can be generated by using the /image command or by providing a prompt in a message.\n"
        "- Conversation Management: The bot maintains a conversation thread in a SQLite database, allowing for persistent and organized conversations.\n"
        "\n"
        "Please note that the bot is still in development, so there might be some bugs. If you encounter any issues, please report them to the bot's developers.",
    )


# Main function that processes all non-command messages
async def maindef(update: Update, context: ContextTypes.DEFAULT_TYPE):



    if update.message:
        message = update.message
    else:
        return

    # Download image and get the prompt
    image, prompt = await download_image(message)

    # Attempt to get the thread_id from the reply_to_message. If it fails (meaning the message is not a reply), then treat the thread_id as the message_id of this message itself.
    try:
        thread_id = str(message.forward_from_message_id)
    except:
        thread_id = str(message.message_id)

    # Add the message to the database
    add_message(thread_id=thread_id, role='user', content=prompt)

    # Read the thread from the database
    messages = read_thread(thread_id=thread_id)

    # Answer to the message
    reply = await message.reply_text('Generating...', parse_mode='HTML')

    # Generate a message using the thread and image
    generated_message = await generate_message(messages, image)

    if 'https://www.bing.com/images/create?q=' in generated_message:
        # If a new image URL is generated, generate a new image
        prompt = generated_message.split('https://www.bing.com/images/create?q=')[1]
        prompt = unquote(prompt)
        urls = generate_image(prompt)
        await reply_with_images(message, urls, prompt)

        # Delete the 'Generating...' message
        await reply.delete()

    else:
        # Update message with the generated message
        if len(generated_message) > 4096:
            await reply.delete()
            for block in split_text(generated_message):
                await message.reply_text(block, parse_mode='HTML')
        else:
            await reply.edit_text(generated_message, parse_mode='HTML')

    # Add the message to the database with the role 'assistant'
    add_message(thread_id=thread_id, role='assistant', content=generated_message)

    # Debugging purpose print statement to display the thread
    print(read_thread(thread_id=thread_id))


# Main function that starts the bot
async def main():
    """Run the bot."""
    # Create the Application and pass it your bot's token.
    application = Application.builder().token(token).local_mode(True).base_url('http://127.0.0.1:8081/bot').base_file_url('http://127.0.0.1:8081/file/bot').build()

    # on different commands - answer in Telegram
    application.add_handler(CommandHandler("start", cmd_start))
    application.add_handler(CommandHandler("help", cmd_help))

    # on inline queries - show corresponding inline results
    application.add_handler(MessageHandler((filters.TEXT | filters.PHOTO) & ~filters.COMMAND, maindef))
    #application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, downloading))

    # Run the bot until the user presses Ctrl-C
    application.run_polling(allowed_updates=Update.ALL_TYPES)


if __name__ == "__main__":
    asyncio.run(main())
